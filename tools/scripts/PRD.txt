# Overview

ClaudeCluster Phase 0 is the smallest viable end-to-end system proving the core concept: a **Hello World** where the **Primary (CLI Driver)** sends a message to a **Worker (Claude Code CLI in a PTY)** via an **MCP Server** that acts as a proxy/router. Workers can run locally in Docker or remotely on Google Cloud Run.

This phase establishes the foundational architecture for parallel Claude Code orchestration by proving we can:
- Launch worker containers with Claude Code CLI in PTY sessions
- Route requests through an MCP server proxy
- Stream live terminal output back to the primary CLI
- Deploy both locally and to cloud infrastructure

The system targets developers who want to experiment with distributed Claude Code workflows and serves as the foundation for future orchestration capabilities.

# Core Features

## Worker Execution Environment
Workers are containerized services running Claude Code CLI in pseudo-terminal sessions.
- HTTP server with health check and execution endpoints
- PTY (pseudo-terminal) integration using node-pty for realistic CLI interaction
- Live streaming of terminal output via Server-Sent Events
- Docker containerization with pre-mounted Claude CLI authentication
- Support for both local Docker and Google Cloud Run deployment
- Clean session lifecycle management and resource cleanup

## MCP Server Proxy
The MCP server acts as a router and proxy between Primary and Workers.
- Task routing and worker selection (static configuration in Phase 0)
- Request forwarding from Primary to appropriate Worker
- Server-Sent Events proxy for streaming terminal output
- In-memory task tracking with unique task IDs
- Worker registry and health monitoring
- HTTP API for task submission and stream consumption

## Primary CLI Interface
Command-line tool for submitting prompts and receiving streamed results.
- Simple run command with prompt input
- Configuration management for local vs cloud deployments
- SSE stream parsing and real-time output display
- Clean error handling and connection management
- Support for different MCP server endpoints
- Extensible configuration system for future features

## Communication Protocol
Standardized JSON-based communication between all components.
- Primary to MCP: task submission with prompt and optional worker targeting
- MCP to Worker: forwarded execution requests
- Worker to MCP to Primary: streamed terminal output via SSE events
- Structured event types for session lifecycle (start/chunk/end)
- Error propagation and status reporting
- Connection health monitoring and cleanup

# User Experience

## Developer Persona
Software engineers and DevOps teams who want to experiment with distributed AI-assisted development workflows. They need a simple way to test Claude Code orchestration concepts and understand the foundational architecture before scaling to production use cases.

## Key User Flows
1. **Local Development**: Developer runs worker in Docker → starts MCP server locally → uses CLI to submit prompts → sees live Claude Code output
2. **Cloud Deployment**: Developer deploys worker to Cloud Run → deploys MCP to Cloud Run → configures CLI for cloud endpoints → submits prompts from anywhere
3. **Experimentation**: Developer modifies prompts and observes how Claude Code responds in real-time through the distributed system

## UI/UX Considerations
- CLI-first design matching developer workflow expectations
- Real-time streaming output identical to direct Claude Code usage
- Clear error messages for connection and deployment issues
- Simple configuration with sensible defaults
- Minimal cognitive overhead for basic usage

# Technical Architecture

## System Components

### Worker Package (@claudecluster/worker)
- Fastify HTTP server with /hello and /run endpoints
- node-pty integration for spawning Claude Code CLI sessions
- Server-Sent Events streaming for real-time output
- Docker containerization with proper PTY dependencies
- Environment configuration for authentication mounting
- Session management and resource cleanup

### MCP Server Package (@claudecluster/mcp)
- Fastify HTTP server with task routing capabilities
- Worker registry and selection logic (static in Phase 0)
- SSE proxy functionality for streaming events
- In-memory task tracking and state management
- Configuration system for worker endpoints
- Health monitoring and error handling

### Primary CLI Package (@claudecluster/cli)
- Command-line interface with run command
- Configuration management for different environments
- SSE client for consuming streamed events
- Output formatting and display logic
- Error handling and user feedback
- Extensible command structure

### Shared Package (@claudecluster/shared)
- Common TypeScript types and interfaces
- SSE event definitions and utilities
- Configuration schemas and validation
- Error types and handling utilities
- Network utilities and helpers
- Logging and monitoring utilities

## Data Models

### Task Model
- taskId: unique identifier for tracking
- prompt: user input to send to Claude Code CLI
- workerTarget: optional specific worker URL
- status: pending/running/completed/failed
- createdAt: timestamp for lifecycle tracking

### Worker Model
- workerId: unique worker identifier
- url: HTTP endpoint for worker communication
- status: online/offline/busy
- capabilities: supported features (extensible)
- deploymentType: local/docker/cloudrun

### SSE Event Model
- event: start/chunk/end event types
- data: JSON payload with event-specific information
- timestamp: when event was generated
- taskId: associated task identifier

## APIs and Integrations

### Primary to MCP API
- POST /tasks: submit task with prompt and optional worker target
- GET /stream/:taskId: consume SSE stream for task output
- GET /workers: list available workers and their status

### MCP to Worker API
- POST /run: forward execution request to worker
- GET /hello: health check and worker information
- GET /healthz: basic health monitoring endpoint

### External Integrations
- Docker daemon for local container management
- Google Cloud Run for serverless worker deployment
- Claude Code CLI for actual AI interaction
- node-pty for terminal session management

## Infrastructure Requirements

### Minimum Local Requirements
- Node.js 18+ runtime environment
- Docker daemon for worker containers
- 4GB RAM for worker containers
- Claude Code CLI installed and authenticated

### Cloud Requirements
- Google Cloud Project with Cloud Run enabled
- Container Registry for image storage
- Public HTTPS endpoints for MCP and Worker services
- Appropriate IAM permissions for deployment

# Development Roadmap

## Phase 0: Hello World Foundation
Build the absolute minimum viable system to prove the concept works end-to-end.

### Monorepo Foundation
- Set up pnpm/turbo monorepo with proper TypeScript configuration
- Create packages structure: shared, worker, mcp, cli
- Configure ESLint, Prettier, and basic CI pipeline
- Establish shared types and common utilities
- Set up testing infrastructure with Jest

### Worker Implementation
- Build Fastify HTTP server with /hello and /run endpoints
- Integrate node-pty for spawning Claude Code CLI sessions
- Implement Server-Sent Events streaming for terminal output
- Create Docker container with proper PTY dependencies
- Handle authentication mounting from host system
- Add session lifecycle management and cleanup

### MCP Server Implementation
- Create Fastify server with task routing capabilities
- Implement worker registry with static configuration
- Build SSE proxy functionality for streaming events
- Add in-memory task tracking with unique IDs
- Handle request forwarding and response proxying
- Implement basic error handling and logging

### Primary CLI Implementation
- Build command-line interface with run command
- Add configuration management for local vs cloud
- Implement SSE client for consuming streamed events
- Create output formatting and display logic
- Handle errors gracefully with user-friendly messages
- Support different MCP server endpoints

### Local Development Setup
- Docker build and run scripts for worker
- Local MCP server startup and configuration
- CLI configuration for local development
- Authentication mounting for Claude Code CLI
- End-to-end testing with Docker containers

### Cloud Deployment
- Google Cloud Run deployment for worker service
- Cloud Run deployment for MCP server
- Container registry integration and image pushing
- Environment configuration for cloud services
- Public endpoint configuration and testing

### Testing and Quality
- Unit tests for core functionality
- Integration tests for component communication
- Smoke tests for deployment verification
- Error handling and edge case testing
- Performance baseline measurements

# Logical Dependency Chain

## Foundation (Must be built first)
1. Monorepo setup and shared types - Required by all packages
2. Worker HTTP server scaffold - Core service foundation
3. PTY integration in worker - Essential for Claude Code interaction
4. Docker containerization - Required for deployment
5. Basic MCP server - Needed for routing and proxying

## Integration (Builds on foundation)
6. MCP task routing and worker forwarding - Connects primary to workers
7. SSE streaming implementation - Enables real-time output
8. Primary CLI with run command - User interface
9. Configuration management - Environment flexibility
10. Local Docker integration - Development workflow

## Deployment (Production readiness)
11. Google Cloud Run worker deployment - Cloud scalability
12. Cloud Run MCP deployment - Centralized routing
13. Container registry integration - Image distribution
14. End-to-end cloud testing - Deployment verification
15. Authentication and security - Production safety

## Quality and Operations
16. Comprehensive testing suite - Reliability assurance
17. Logging and monitoring - Operational visibility
18. Error handling and recovery - Robustness
19. Documentation and examples - Developer experience
20. Performance optimization - Efficiency

# Risks and Mitigations

## Technical Risks

### PTY Dependencies in Containers
Risk: node-pty may not work properly in Docker containers
Mitigation: Use Debian slim base image with required PTY libraries, test locally first, document specific dependencies

### Claude CLI Authentication
Risk: Mounting authentication may fail or be insecure
Mitigation: Use read-only volume mounts, document exact paths, provide fallback configuration options

### SSE Proxy Latency
Risk: Streaming through MCP proxy may introduce unacceptable delays
Mitigation: Implement efficient streaming with proper headers, avoid buffering, test with realistic payloads

### Cloud Run Cold Starts
Risk: Worker containers may have high latency on first request
Mitigation: Configure minimum instances appropriately, implement proper warming strategies, document expected behavior

## Operational Risks

### Container Resource Limits
Risk: Workers may exhaust memory or CPU in containers
Mitigation: Set appropriate resource limits, implement timeouts, monitor resource usage, clean up sessions

### Network Connectivity
Risk: Communication between MCP and Workers may fail
Mitigation: Implement retry logic, health checks, graceful degradation, proper error reporting

### Session Management
Risk: Abandoned or long-running sessions may consume resources
Mitigation: Implement session timeouts, cleanup on disconnect, resource monitoring, process termination

## Security Risks

### Unauthenticated Endpoints
Risk: Phase 0 uses unauthenticated endpoints for simplicity
Mitigation: Document security limitations, plan authentication for Phase 1, use private networks where possible

### Credential Exposure
Risk: Claude CLI credentials mounted in containers
Mitigation: Use read-only mounts, container isolation, proper file permissions, credential rotation planning

# Appendix

## Research Findings
- node-pty works reliably in Docker containers with proper base images
- Server-Sent Events provide efficient real-time streaming for terminal output
- Google Cloud Run supports container applications with proper configuration
- Fastify provides excellent performance for proxy/routing use cases

## Technical Specifications
- Node.js 18+ with TypeScript for all components
- Fastify web framework for HTTP servers
- node-pty for pseudo-terminal integration
- Server-Sent Events for real-time streaming
- Docker containers with Debian slim base images
- Google Cloud Run for serverless deployment
- pnpm for package management and monorepo tooling
- Turbo for build system and task orchestration