/**\n * Security utilities for configuration management\n */\n\nimport { readFile } from 'fs/promises';\nimport { join } from 'path';\n\n/**\n * Sensitive configuration keys that should be masked in logs and error messages\n */\nexport const SENSITIVE_KEYS = [\n  'apikey',\n  'api_key',\n  'secret',\n  'password',\n  'pwd',\n  'token',\n  'auth',\n  'credential',\n  'cert',\n  'certificate',\n  'private',\n  'key',\n  'passphrase',\n  'serviceaccount',\n  'service_account',\n  'connectionstring',\n  'connection_string',\n  'databaseurl',\n  'database_url',\n  'oauth',\n  'bearer',\n  'authorization',\n  'clientsecret',\n  'client_secret'\n] as const;\n\n/**\n * Configuration paths that should be treated as sensitive\n */\nexport const SENSITIVE_PATHS = [\n  'auth.apiKey',\n  'auth.clientSecret',\n  'database.password',\n  'database.connectionString',\n  'logging.apiKey',\n  'monitoring.apiKey',\n  'server.tlsKey',\n  'server.tlsCert',\n  'workers.authToken',\n  'oauth.clientSecret',\n  'oauth.privateKey'\n] as const;\n\n/**\n * Check if a configuration key or path should be treated as sensitive\n */\nexport function isSensitive(key: string): boolean {\n  const lowerKey = key.toLowerCase();\n  \n  // Check if any sensitive keyword is in the key\n  return SENSITIVE_KEYS.some(sensitiveKey => \n    lowerKey.includes(sensitiveKey)\n  ) || SENSITIVE_PATHS.some(path => \n    key.toLowerCase().includes(path.toLowerCase())\n  );\n}\n\n/**\n * Mask sensitive values in configuration objects\n */\nexport function maskSensitiveValues(obj: any, parentPath = ''): any {\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n  \n  if (typeof obj !== 'object') {\n    return obj;\n  }\n  \n  if (Array.isArray(obj)) {\n    return obj.map((item, index) => \n      maskSensitiveValues(item, `${parentPath}[${index}]`)\n    );\n  }\n  \n  const result: any = {};\n  \n  for (const [key, value] of Object.entries(obj)) {\n    const currentPath = parentPath ? `${parentPath}.${key}` : key;\n    \n    if (isSensitive(currentPath)) {\n      // Mask sensitive values\n      if (typeof value === 'string') {\n        if (value.length <= 4) {\n          result[key] = '***';\n        } else {\n          result[key] = `${value.substring(0, 2)}***${value.substring(value.length - 2)}`;\n        }\n      } else {\n        result[key] = '[REDACTED]';\n      }\n    } else if (typeof value === 'object') {\n      result[key] = maskSensitiveValues(value, currentPath);\n    } else {\n      result[key] = value;\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Create a safe version of configuration for logging\n */\nexport function createSafeConfigForLogging(config: any): any {\n  return maskSensitiveValues(config);\n}\n\n/**\n * Validate that no sensitive values are accidentally exposed in plain text\n */\nexport function validateConfigSecurity(config: any, source: string): string[] {\n  const warnings: string[] = [];\n  \n  function checkObject(obj: any, path = ''): void {\n    if (!obj || typeof obj !== 'object') return;\n    \n    for (const [key, value] of Object.entries(obj)) {\n      const currentPath = path ? `${path}.${key}` : key;\n      \n      if (isSensitive(currentPath)) {\n        if (typeof value === 'string') {\n          // Check for common patterns that indicate exposed secrets\n          if (value.startsWith('sk-') || // OpenAI API keys\n              value.startsWith('xoxb-') || // Slack tokens\n              value.startsWith('ghp_') || // GitHub tokens\n              value.match(/^[A-Za-z0-9]{32,}$/) || // Generic long tokens\n              value.includes('://') && value.includes('@')) { // Connection strings with credentials\n            \n            warnings.push(\n              `Potential exposed secret in ${source} at \"${currentPath}\": ` +\n              `Value appears to be a real credential. Consider using environment ` +\n              `variables or secret management instead.`\n            );\n          }\n          \n          if (value === 'your-api-key-here' || \n              value === 'change-me' || \n              value === 'secret' ||\n              value === 'password' ||\n              value === 'token') {\n            warnings.push(\n              `Default/placeholder value detected in ${source} at \"${currentPath}\": ` +\n              `Replace with actual value from secure source.`\n            );\n          }\n        }\n      }\n      \n      if (typeof value === 'object' && value !== null) {\n        checkObject(value, currentPath);\n      }\n    }\n  }\n  \n  checkObject(config);\n  return warnings;\n}\n\n/**\n * Load sensitive configuration values from files (e.g., mounted secrets)\n */\nexport async function loadSecretFromFile(filePath: string): Promise<string> {\n  try {\n    const content = await readFile(filePath, 'utf-8');\n    return content.trim();\n  } catch (error) {\n    throw new Error(`Failed to load secret from ${filePath}: ${error}`);\n  }\n}\n\n/**\n * Load multiple secrets from a directory\n */\nexport async function loadSecretsFromDirectory(dirPath: string): Promise<Record<string, string>> {\n  try {\n    const { readdir } = await import('fs/promises');\n    const files = await readdir(dirPath);\n    const secrets: Record<string, string> = {};\n    \n    for (const file of files) {\n      if (file.startsWith('.')) continue; // Skip hidden files\n      \n      try {\n        const content = await loadSecretFromFile(join(dirPath, file));\n        secrets[file] = content;\n      } catch (error) {\n        console.warn(`Warning: Could not load secret from ${file}:`, error);\n      }\n    }\n    \n    return secrets;\n  } catch (error) {\n    throw new Error(`Failed to load secrets from directory ${dirPath}: ${error}`);\n  }\n}\n\n/**\n * Replace configuration values with secrets loaded from files\n */\nexport async function replaceSecretsFromFiles(config: any): Promise<any> {\n  const result = JSON.parse(JSON.stringify(config)); // Deep clone\n  \n  async function processValue(obj: any, key: string, value: any): Promise<void> {\n    if (typeof value === 'string' && value.startsWith('file://')) {\n      const filePath = value.substring(7); // Remove 'file://' prefix\n      try {\n        obj[key] = await loadSecretFromFile(filePath);\n      } catch (error) {\n        throw new Error(`Failed to load secret for ${key} from ${filePath}: ${error}`);\n      }\n    } else if (typeof value === 'object' && value !== null) {\n      await processObject(value);\n    }\n  }\n  \n  async function processObject(obj: any): Promise<void> {\n    if (Array.isArray(obj)) {\n      for (let i = 0; i < obj.length; i++) {\n        await processValue(obj, i.toString(), obj[i]);\n      }\n    } else {\n      for (const [key, value] of Object.entries(obj)) {\n        await processValue(obj, key, value);\n      }\n    }\n  }\n  \n  await processObject(result);\n  return result;\n}\n\n/**\n * Environment variable patterns that suggest secrets\n */\nconst SECRET_ENV_PATTERNS = [\n  /_API_KEY$/,\n  /_SECRET$/,\n  /_TOKEN$/,\n  /_PASSWORD$/,\n  /_PRIVATE_KEY$/,\n  /_CLIENT_SECRET$/,\n  /_CONNECTION_STRING$/,\n  /_DATABASE_URL$/,\n  /^DATABASE_URL$/,\n  /^SECRET_/,\n  /^PRIVATE_/\n];\n\n/**\n * Audit environment variables for potential security issues\n */\nexport function auditEnvironmentVariables(): {\n  warnings: string[];\n  recommendations: string[];\n} {\n  const warnings: string[] = [];\n  const recommendations: string[] = [];\n  \n  for (const [key, value] of Object.entries(process.env)) {\n    if (!value) continue;\n    \n    // Check if environment variable name suggests it contains secrets\n    const isLikelySecret = SECRET_ENV_PATTERNS.some(pattern => pattern.test(key));\n    \n    if (isLikelySecret) {\n      // Check if value looks like a real secret vs placeholder\n      if (value === 'your-secret-here' || \n          value === 'change-me' || \n          value === 'secret' ||\n          value.length < 8) {\n        warnings.push(\n          `Environment variable ${key} appears to contain a placeholder value. ` +\n          'Ensure it is set to the actual secret value.'\n        );\n      }\n      \n      // Check for common insecure patterns\n      if (value.startsWith('http://')) {\n        warnings.push(\n          `Environment variable ${key} contains HTTP URL. ` +\n          'Consider using HTTPS for security.'\n        );\n      }\n    }\n    \n    // Check for accidentally exposed secrets in non-secret variables\n    if (!isLikelySecret && isSensitive(key.toLowerCase())) {\n      recommendations.push(\n        `Environment variable ${key} may contain sensitive data. ` +\n        'Consider renaming to follow secure naming conventions (e.g., add _SECRET suffix).'\n      );\n    }\n  }\n  \n  return { warnings, recommendations };\n}\n\n/**\n * Generate secure configuration template with placeholders\n */\nexport function generateSecureConfigTemplate(componentType: 'cli' | 'mcp' | 'worker'): string {\n  const templates = {\n    cli: {\n      server: {\n        url: 'https://your-mcp-server.com',\n        timeout: 30000\n      },\n      logging: {\n        level: 'info',\n        format: 'simple'\n      },\n      defaults: {\n        priority: 5,\n        timeout: 300\n      },\n      '_security_note': 'Place sensitive values in environment variables or secret files, not in this config file'\n    },\n    mcp: {\n      server: {\n        host: '0.0.0.0',\n        port: 3000\n      },\n      workers: {\n        endpoints: ['https://worker-1.example.com', 'https://worker-2.example.com'],\n        maxRetries: 3,\n        requestTimeoutMs: 30000\n      },\n      logging: {\n        level: 'info',\n        format: 'json'\n      },\n      '_security_note': 'Sensitive values should be provided via environment variables',\n      '_example_env_vars': {\n        'CLAUDECLUSTER_MCP_API_KEY': 'your-api-key-here',\n        'CLAUDECLUSTER_MCP_DATABASE_PASSWORD': 'file:///secrets/db-password'\n      }\n    },\n    worker: {\n      server: {\n        host: '0.0.0.0',\n        port: 3001\n      },\n      worker: {\n        id: 'worker-1',\n        capabilities: {\n          maxConcurrentTasks: 1,\n          supportedCommands: ['run']\n        }\n      },\n      logging: {\n        level: 'info',\n        format: 'json'\n      },\n      '_security_note': 'Use environment variables for worker authentication and sensitive configuration'\n    }\n  };\n  \n  return JSON.stringify(templates[componentType], null, 2);\n}\n\n/**\n * Security recommendations for configuration\n */\nexport const SECURITY_RECOMMENDATIONS = {\n  general: [\n    'Never commit sensitive configuration values to version control',\n    'Use environment variables for sensitive values in development',\n    'Use secret management systems (e.g., Google Secret Manager, AWS Secrets Manager) in production',\n    'Regularly rotate API keys and secrets',\n    'Use HTTPS for all external communication',\n    'Implement proper access controls for configuration files',\n    'Monitor and audit configuration access'\n  ],\n  \n  development: [\n    'Use .env files for local development secrets (add .env to .gitignore)',\n    'Use different secrets for development vs production',\n    'Consider using docker-compose secrets for containerized development',\n    'Use file:// prefixes to load secrets from mounted files'\n  ],\n  \n  production: [\n    'Use dedicated secret management services',\n    'Mount secrets as files in containers rather than environment variables',\n    'Implement secret rotation policies',\n    'Use service accounts with minimal required permissions',\n    'Enable audit logging for secret access',\n    'Use encrypted communication between components'\n  ],\n  \n  cloudRun: [\n    'Use Google Secret Manager for all sensitive values',\n    'Mount secrets as volumes rather than environment variables',\n    'Use IAM service accounts with principle of least privilege',\n    'Enable VPC connectors for internal communication',\n    'Use Cloud KMS for additional encryption of sensitive data'\n  ],\n  \n  docker: [\n    'Use Docker secrets for sensitive values',\n    'Avoid passing secrets as build arguments',\n    'Use multi-stage builds to avoid exposing secrets in layers',\n    'Implement proper secret rotation in orchestration systems'\n  ]\n};\n\nexport default {\n  isSensitive,\n  maskSensitiveValues,\n  createSafeConfigForLogging,\n  validateConfigSecurity,\n  loadSecretFromFile,\n  loadSecretsFromDirectory,\n  replaceSecretsFromFiles,\n  auditEnvironmentVariables,\n  generateSecureConfigTemplate,\n  SECURITY_RECOMMENDATIONS\n};"