/**\n * Enhanced configuration validation utilities\n */\n\nimport { z } from 'zod';\nimport {\n  cliConfigSchema,\n  mcpConfigSchema,\n  workerNodeConfigSchema,\n  CLIConfig,\n  MCPConfig,\n  WorkerNodeConfig\n} from './config.js';\n\n/**\n * Validation error details\n */\nexport interface ValidationError {\n  path: string;\n  message: string;\n  code: string;\n  received?: unknown;\n  expected?: string;\n}\n\n/**\n * Validation result with detailed error information\n */\nexport interface ValidationResult<T> {\n  success: boolean;\n  data?: T;\n  errors: ValidationError[];\n  warnings: string[];\n}\n\n/**\n * Enhanced configuration validator with detailed error reporting\n */\nexport class ConfigValidator {\n  /**\n   * Validate CLI configuration with detailed error reporting\n   */\n  static validateCLIConfig(config: unknown): ValidationResult<CLIConfig> {\n    return this.validateWithSchema(cliConfigSchema, config, 'CLI');\n  }\n  \n  /**\n   * Validate MCP configuration with detailed error reporting\n   */\n  static validateMCPConfig(config: unknown): ValidationResult<MCPConfig> {\n    return this.validateWithSchema(mcpConfigSchema, config, 'MCP');\n  }\n  \n  /**\n   * Validate Worker configuration with detailed error reporting\n   */\n  static validateWorkerConfig(config: unknown): ValidationResult<WorkerNodeConfig> {\n    return this.validateWithSchema(workerNodeConfigSchema, config, 'Worker');\n  }\n  \n  /**\n   * Generic schema validation with enhanced error reporting\n   */\n  private static validateWithSchema<T>(\n    schema: z.ZodSchema<T>,\n    config: unknown,\n    configType: string\n  ): ValidationResult<T> {\n    try {\n      const result = schema.parse(config);\n      return {\n        success: true,\n        data: result,\n        errors: [],\n        warnings: []\n      };\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const errors = error.issues.map(issue => this.formatZodError(issue, configType));\n        return {\n          success: false,\n          errors,\n          warnings: []\n        };\n      }\n      \n      return {\n        success: false,\n        errors: [{\n          path: 'unknown',\n          message: `Unexpected validation error: ${error}`,\n          code: 'UNKNOWN_ERROR'\n        }],\n        warnings: []\n      };\n    }\n  }\n  \n  /**\n   * Format Zod error into a more user-friendly format\n   */\n  private static formatZodError(issue: z.ZodIssue, configType: string): ValidationError {\n    const path = issue.path.join('.');\n    \n    switch (issue.code) {\n      case z.ZodIssueCode.invalid_type:\n        return {\n          path,\n          message: `Expected ${issue.expected}, but received ${issue.received}`,\n          code: 'INVALID_TYPE',\n          received: issue.received,\n          expected: issue.expected\n        };\n      \n      case z.ZodIssueCode.invalid_string:\n        if (issue.validation === 'url') {\n          return {\n            path,\n            message: 'Must be a valid URL (e.g., http://localhost:3000)',\n            code: 'INVALID_URL',\n            received: issue.received\n          };\n        }\n        return {\n          path,\n          message: `Invalid string format: ${issue.message}`,\n          code: 'INVALID_STRING',\n          received: issue.received\n        };\n      \n      case z.ZodIssueCode.too_small:\n        if (issue.type === 'number') {\n          return {\n            path,\n            message: `Must be at least ${issue.minimum}`,\n            code: 'TOO_SMALL',\n            received: issue.received,\n            expected: `>= ${issue.minimum}`\n          };\n        }\n        return {\n          path,\n          message: `Value is too small: ${issue.message}`,\n          code: 'TOO_SMALL',\n          received: issue.received\n        };\n      \n      case z.ZodIssueCode.too_big:\n        if (issue.type === 'number') {\n          return {\n            path,\n            message: `Must be at most ${issue.maximum}`,\n            code: 'TOO_BIG',\n            received: issue.received,\n            expected: `<= ${issue.maximum}`\n          };\n        }\n        return {\n          path,\n          message: `Value is too big: ${issue.message}`,\n          code: 'TOO_BIG',\n          received: issue.received\n        };\n      \n      case z.ZodIssueCode.invalid_enum_value:\n        return {\n          path,\n          message: `Must be one of: ${issue.options.join(', ')}`,\n          code: 'INVALID_ENUM',\n          received: issue.received,\n          expected: issue.options.join(' | ')\n        };\n      \n      case z.ZodIssueCode.invalid_literal:\n        return {\n          path,\n          message: `Must be exactly \"${issue.expected}\"`,\n          code: 'INVALID_LITERAL',\n          received: issue.received,\n          expected: String(issue.expected)\n        };\n      \n      case z.ZodIssueCode.invalid_union:\n        return {\n          path,\n          message: 'Value does not match any expected format',\n          code: 'INVALID_UNION',\n          received: issue.received\n        };\n      \n      default:\n        return {\n          path,\n          message: issue.message || 'Validation failed',\n          code: issue.code.toUpperCase(),\n          received: 'received' in issue ? issue.received : undefined\n        };\n    }\n  }\n  \n  /**\n   * Get helpful suggestions for common configuration errors\n   */\n  static getSuggestions(errors: ValidationError[], configType: string): string[] {\n    const suggestions: string[] = [];\n    \n    for (const error of errors) {\n      if (error.code === 'INVALID_URL') {\n        if (error.path.includes('server.url')) {\n          suggestions.push('Server URL must include protocol (http:// or https://) and be properly formatted');\n          suggestions.push('Example: \"http://localhost:3000\" or \"https://api.example.com\"');\n        }\n        if (error.path.includes('endpoints')) {\n          suggestions.push('Worker endpoints must be valid URLs with protocol and port');\n          suggestions.push('Example: [\"http://worker1:3001\", \"http://worker2:3001\"]');\n        }\n      }\n      \n      if (error.code === 'TOO_SMALL' || error.code === 'TOO_BIG') {\n        if (error.path.includes('port')) {\n          suggestions.push('Port numbers must be between 1 and 65535');\n        }\n        if (error.path.includes('priority')) {\n          suggestions.push('Priority must be between 1 (lowest) and 10 (highest)');\n        }\n        if (error.path.includes('timeout')) {\n          suggestions.push('Timeout values must be positive numbers (in milliseconds for technical settings, seconds for user settings)');\n        }\n        if (error.path.includes('maxConcurrentTasks')) {\n          suggestions.push('Maximum concurrent tasks must be at least 1 and reasonable for your system resources');\n        }\n      }\n      \n      if (error.code === 'INVALID_ENUM') {\n        if (error.path.includes('level')) {\n          suggestions.push('Log level must be one of: error, warn, info, debug');\n          suggestions.push('Use \"info\" for normal operation, \"debug\" for troubleshooting');\n        }\n        if (error.path.includes('selectionStrategy')) {\n          suggestions.push('Worker selection strategy determines how tasks are distributed');\n          suggestions.push('\"round-robin\" distributes evenly, \"least-loaded\" prefers less busy workers');\n        }\n        if (error.path.includes('format')) {\n          suggestions.push('Log format: \"simple\" for human-readable logs, \"json\" for structured logging');\n        }\n      }\n      \n      if (error.code === 'INVALID_TYPE') {\n        if (error.expected === 'number' && error.received === 'string') {\n          suggestions.push(`\"${error.path}\" should be a number, not a string (remove quotes)`);\n        }\n        if (error.expected === 'string' && error.received === 'number') {\n          suggestions.push(`\"${error.path}\" should be a string (add quotes)`);\n        }\n        if (error.expected === 'array') {\n          suggestions.push(`\"${error.path}\" should be an array, e.g., [\"item1\", \"item2\"]`);\n        }\n      }\n    }\n    \n    // Add general suggestions\n    if (errors.length > 0) {\n      suggestions.push(`Check the ${configType} configuration documentation for complete examples`);\n      suggestions.push('Use environment variables to override config file values if needed');\n    }\n    \n    return [...new Set(suggestions)]; // Remove duplicates\n  }\n  \n  /**\n   * Format validation errors for display to users\n   */\n  static formatErrorsForDisplay(errors: ValidationError[], configType: string): string {\n    if (errors.length === 0) {\n      return '';\n    }\n    \n    const lines = [\n      `${configType} Configuration Validation Errors:`,\n      ''\n    ];\n    \n    for (const error of errors) {\n      const pathDisplay = error.path ? `\"${error.path}\"` : 'configuration';\n      lines.push(`âŒ ${pathDisplay}: ${error.message}`);\n      \n      if (error.received !== undefined) {\n        lines.push(`   Received: ${JSON.stringify(error.received)}`);\n      }\n      \n      if (error.expected) {\n        lines.push(`   Expected: ${error.expected}`);\n      }\n      \n      lines.push(''); // Empty line between errors\n    }\n    \n    const suggestions = this.getSuggestions(errors, configType);\n    if (suggestions.length > 0) {\n      lines.push('ðŸ’¡ Suggestions:');\n      for (const suggestion of suggestions) {\n        lines.push(`   â€¢ ${suggestion}`);\n      }\n    }\n    \n    return lines.join('\\n');\n  }\n}\n\n/**\n * Validate configuration and throw descriptive error if invalid\n */\nexport function validateConfigOrThrow<T>(\n  schema: z.ZodSchema<T>,\n  config: unknown,\n  configType: string\n): T {\n  const validator = ConfigValidator as any;\n  const methodMap = {\n    'CLI': 'validateCLIConfig',\n    'MCP': 'validateMCPConfig',\n    'Worker': 'validateWorkerConfig'\n  };\n  \n  const method = methodMap[configType as keyof typeof methodMap];\n  const result = method ? validator[method](config) : \n    ConfigValidator['validateWithSchema'](schema, config, configType);\n  \n  if (!result.success) {\n    const errorMessage = ConfigValidator.formatErrorsForDisplay(result.errors, configType);\n    throw new Error(`Configuration validation failed:\\n\\n${errorMessage}`);\n  }\n  \n  return result.data!;\n}"