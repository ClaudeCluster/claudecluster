/**\n * Tests for configuration loading and validation\n */\n\nimport { \n  ConfigLoader,\n  createCLIConfigLoader,\n  createMCPConfigLoader,\n  createWorkerConfigLoader,\n  cliConfigSchema,\n  mcpConfigSchema,\n  workerNodeConfigSchema\n} from '../config.js';\nimport { z } from 'zod';\n\ndescribe('Configuration Validation', () => {\n  describe('CLI Configuration Schema', () => {\n    it('should validate valid CLI configuration', () => {\n      const validConfig = {\n        server: {\n          url: 'http://localhost:3000',\n          timeout: 30000\n        },\n        logging: {\n          level: 'info',\n          console: true,\n          format: 'simple'\n        },\n        defaults: {\n          priority: 5,\n          timeout: 300\n        }\n      };\n      \n      const result = cliConfigSchema.parse(validConfig);\n      expect(result).toEqual(validConfig);\n    });\n    \n    it('should apply defaults for missing fields', () => {\n      const minimalConfig = {};\n      \n      const result = cliConfigSchema.parse(minimalConfig);\n      \n      expect(result.server.url).toBe('http://localhost:3000');\n      expect(result.server.timeout).toBe(30000);\n      expect(result.logging.level).toBe('info');\n      expect(result.defaults.priority).toBe(5);\n    });\n    \n    it('should reject invalid server URL', () => {\n      const invalidConfig = {\n        server: {\n          url: 'not-a-valid-url'\n        }\n      };\n      \n      expect(() => cliConfigSchema.parse(invalidConfig)).toThrow();\n    });\n    \n    it('should reject invalid priority value', () => {\n      const invalidConfig = {\n        defaults: {\n          priority: 15 // Out of range (1-10)\n        }\n      };\n      \n      expect(() => cliConfigSchema.parse(invalidConfig)).toThrow();\n    });\n    \n    it('should reject invalid log level', () => {\n      const invalidConfig = {\n        logging: {\n          level: 'invalid-level'\n        }\n      };\n      \n      expect(() => cliConfigSchema.parse(invalidConfig)).toThrow();\n    });\n  });\n  \n  describe('MCP Configuration Schema', () => {\n    it('should validate valid MCP configuration', () => {\n      const validConfig = {\n        server: {\n          host: 'localhost',\n          port: 3000\n        },\n        workers: {\n          endpoints: ['http://localhost:3001'],\n          maxRetries: 3,\n          selectionStrategy: 'round-robin'\n        },\n        logging: {\n          level: 'info'\n        }\n      };\n      \n      const result = mcpConfigSchema.parse(validConfig);\n      expect(result.server.host).toBe('localhost');\n      expect(result.server.port).toBe(3000);\n      expect(result.workers.endpoints).toEqual(['http://localhost:3001']);\n    });\n    \n    it('should reject invalid worker endpoints', () => {\n      const invalidConfig = {\n        workers: {\n          endpoints: ['not-a-url', 'also-invalid']\n        }\n      };\n      \n      expect(() => mcpConfigSchema.parse(invalidConfig)).toThrow();\n    });\n    \n    it('should reject invalid port numbers', () => {\n      const invalidConfig = {\n        server: {\n          port: 70000 // Out of range\n        }\n      };\n      \n      expect(() => mcpConfigSchema.parse(invalidConfig)).toThrow();\n    });\n    \n    it('should reject invalid selection strategy', () => {\n      const invalidConfig = {\n        workers: {\n          selectionStrategy: 'invalid-strategy'\n        }\n      };\n      \n      expect(() => mcpConfigSchema.parse(invalidConfig)).toThrow();\n    });\n  });\n  \n  describe('Worker Configuration Schema', () => {\n    it('should validate valid Worker configuration', () => {\n      const validConfig = {\n        server: {\n          host: 'localhost',\n          port: 3001\n        },\n        worker: {\n          id: 'worker-1',\n          capabilities: {\n            maxConcurrentTasks: 2,\n            supportedCommands: ['run', 'test'],\n            timeout: 300000\n          }\n        }\n      };\n      \n      const result = workerNodeConfigSchema.parse(validConfig);\n      expect(result.worker.id).toBe('worker-1');\n      expect(result.worker.capabilities.maxConcurrentTasks).toBe(2);\n    });\n    \n    it('should reject invalid concurrent tasks limit', () => {\n      const invalidConfig = {\n        worker: {\n          capabilities: {\n            maxConcurrentTasks: 0 // Must be at least 1\n          }\n        }\n      };\n      \n      expect(() => workerNodeConfigSchema.parse(invalidConfig)).toThrow();\n    });\n    \n    it('should reject invalid timeout values', () => {\n      const invalidConfig = {\n        worker: {\n          capabilities: {\n            timeout: 500 // Too short (< 1000ms)\n          }\n        }\n      };\n      \n      expect(() => workerNodeConfigSchema.parse(invalidConfig)).toThrow();\n    });\n  });\n});\n\ndescribe('Configuration Loading', () => {\n  describe('ConfigLoader', () => {\n    it('should create CLI config loader with correct options', () => {\n      const loader = createCLIConfigLoader();\n      \n      expect(loader).toBeInstanceOf(ConfigLoader);\n      expect(loader['options'].component).toBe('cli');\n      expect(loader['options'].envPrefix).toBe('CLAUDECLUSTER_CLI_');\n    });\n    \n    it('should create MCP config loader with correct options', () => {\n      const loader = createMCPConfigLoader();\n      \n      expect(loader).toBeInstanceOf(ConfigLoader);\n      expect(loader['options'].component).toBe('mcp');\n      expect(loader['options'].envPrefix).toBe('CLAUDECLUSTER_MCP_');\n    });\n    \n    it('should create Worker config loader with correct options', () => {\n      const loader = createWorkerConfigLoader();\n      \n      expect(loader).toBeInstanceOf(ConfigLoader);\n      expect(loader['options'].component).toBe('worker');\n      expect(loader['options'].envPrefix).toBe('CLAUDECLUSTER_WORKER_');\n    });\n  });\n  \n  describe('Environment Variable Loading', () => {\n    const originalEnv = process.env;\n    \n    beforeEach(() => {\n      // Clear environment\n      process.env = { ...originalEnv };\n    });\n    \n    afterAll(() => {\n      process.env = originalEnv;\n    });\n    \n    it('should load configuration from environment variables', async () => {\n      // Set test environment variables\n      process.env.CLAUDECLUSTER_CLI_SERVER_URL = 'http://test:3000';\n      process.env.CLAUDECLUSTER_CLI_LOGGING_LEVEL = 'debug';\n      process.env.CLAUDECLUSTER_CLI_DEFAULTS_PRIORITY = '8';\n      \n      const loader = createCLIConfigLoader({\n        loadDotenv: false, // Skip .env loading in tests\n        searchPaths: [] // Skip file loading in tests\n      });\n      \n      const result = await loader.load();\n      \n      expect(result.config.server.url).toBe('http://test:3000');\n      expect(result.config.logging.level).toBe('debug');\n      expect(result.config.defaults.priority).toBe(8);\n    });\n    \n    it('should handle nested configuration via dot notation', async () => {\n      process.env.CLAUDECLUSTER_MCP_SERVER_HOST = 'testhost';\n      process.env.CLAUDECLUSTER_MCP_SERVER_PORT = '4000';\n      process.env.CLAUDECLUSTER_MCP_WORKERS_MAXRETRIES = '5';\n      \n      const loader = createMCPConfigLoader({\n        loadDotenv: false,\n        searchPaths: []\n      });\n      \n      const result = await loader.load();\n      \n      expect(result.config.server.host).toBe('testhost');\n      expect(result.config.server.port).toBe(4000);\n      expect(result.config.workers.maxRetries).toBe(5);\n    });\n    \n    it('should parse JSON values in environment variables', async () => {\n      process.env.CLAUDECLUSTER_MCP_WORKERS_ENDPOINTS = JSON.stringify([\n        'http://worker1:3001',\n        'http://worker2:3001'\n      ]);\n      \n      const loader = createMCPConfigLoader({\n        loadDotenv: false,\n        searchPaths: []\n      });\n      \n      const result = await loader.load();\n      \n      expect(result.config.workers.endpoints).toEqual([\n        'http://worker1:3001',\n        'http://worker2:3001'\n      ]);\n    });\n  });\n  \n  describe('Configuration Validation Errors', () => {\n    it('should return validation errors for invalid configuration', async () => {\n      const loader = new ConfigLoader({\n        component: 'cli',\n        schema: cliConfigSchema,\n        validateSchema: true,\n        loadDotenv: false,\n        searchPaths: []\n      });\n      \n      // Mock the loadFromEnvironment to return invalid config\n      const originalLoadFromEnv = loader['loadFromEnvironment'];\n      loader['loadFromEnvironment'] = () => ({\n        type: 'env',\n        data: {\n          server: {\n            url: 'invalid-url', // This should fail validation\n            timeout: -1 // This should also fail\n          }\n        }\n      });\n      \n      const result = await loader.load();\n      \n      expect(result.errors.length).toBeGreaterThan(0);\n      expect(result.errors[0]).toContain('validation failed');\n      \n      // Restore original method\n      loader['loadFromEnvironment'] = originalLoadFromEnv;\n    });\n  });\n});\n\ndescribe('Configuration Precedence', () => {\n  it('should demonstrate precedence order', async () => {\n    // This test would require mocking file system and environment\n    // For now, we'll test the merging logic directly\n    const loader = new ConfigLoader({\n      component: 'cli',\n      schema: z.record(z.unknown()),\n      validateSchema: false,\n      loadDotenv: false,\n      searchPaths: []\n    });\n    \n    const sources = [\n      { type: 'file' as const, data: { server: { url: 'http://file:3000' }, priority: 1 } },\n      { type: 'env' as const, data: { server: { url: 'http://env:3000' }, logging: { level: 'debug' } } }\n    ];\n    \n    const merged = loader['mergeConfigs'](sources.map(s => s.data));\n    \n    // Environment should override file\n    expect(merged.server.url).toBe('http://env:3000');\n    // Both values should be present\n    expect(merged.priority).toBe(1);\n    expect(merged.logging.level).toBe('debug');\n  });\n});"